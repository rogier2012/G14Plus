%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Slightly updated by  Marc Uetz
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside]{article}

\usepackage{lipsum} % Package to generate dummy text throughout this template

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}[section]


\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage[dutch]{babel}
\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them
\usepackage{algorithmicx}
\usepackage[]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{pifont}
\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{R.\ Monshouwer, C.H.M.\ van den Bogaard, F.\ Seuren, D.T.R. Ikink: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\articletitle}{Fast partition refinement, a Python implementation}
\newcommand{\shorttitle}{Python fast partitioning}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Christiaan van den Bogaard, Dion Ikink, Fleur Seuren, and Rogier Monshouwer}\thanks{Thanks to our helpful mentor.}\\[2mm] % Your name
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:d.t.r.ikink@student.utwente.nl}{d.t.r.ikink@student.utwente.nl}, 
\href{mailto:c.h.m.vandenbogaard@student.utwente.nl}{c.h.m.vandenbogaard@student.utwente.nl} \\
\normalsize\href{mailto:f.seuren@student.utwente.nl}{f.seuren@student.utwente.nl}, % Your email addresses
\href{mailto:r.monshouwer@student.utwente.nl}{r.monshouwer@student.utwente.nl}
}

\date{\today}

%----------------------------------------------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\begin{abstract}

\noindent \lipsum[1] % Dummy abstract text

\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\begin{multicols}{2} % Two-column layout throughout the main article text



%------------------------------------------------
\begin{quote}
\textit{''Gegeven twee eindige graven G en H, bestaat er een isomorfisme tussen G en H?''}
\end{quote}

Het bovenstaande probleem staat bekend als het graaf isomorfisme probleem  (GI), één van de meest bestudeerde onderwerpen binnen de discrete wiskunde en theoretische informatica. Hoewel dit probleem voor verschillende klassen van graven is opgelost  en er honderden onderzoeken over zijn gepubliceerd is er nog altijd geen efficiënte oplossing gevonden die toepasbaar is op alle mogelijk graven. Niet voor niets bevindt de complexiteit van dit probleem zich in een geheel nieuwe complexiteitsklasse, tussen de problemen die oplosbaar zijn in polynomiale tijd (P) en de beslisproblemen wiens oplossingen verifieerbaar zijn in polynomiale tijd (NP-complete).

Een van de bestaande technieken die veel gebruikt wordt om het GI probleem op te lossen is ''partition refinement''. In dit artikel zal het idee achter ''partition refinement'' uitgelegd worden. Daarnaast zal er zeer effici\"ente Python implementatie van deze techniek gegeven worden. Dit algoritme, dat gebaseerd is op een door Hopcroft~\cite{MR0403320} bedacht algoritme voor het minimaliseren van DFA's heeft namelijk een complexiteitklasse van $O(m \log_{2} (n)$ met $m= \text{aantal lijnen}$ en $n = \text{aantal punten}$, terwijl een standaard implementatie maar een complexiteitsklasse van $O(n^2)$ heeft.

%------------------------------------------------
\section{Theoretische onderbouwing}
In deze sectie zal de theorie achter zowel ''partition refinement'' als het algoritme van Hopcroft worden uitgelegd.

\subsection{Partition refinement}
Het idee achter partition refinement is dat een isomorfisme de omgeving, de verzameling buren, van een punt $v$ in stand houdt. Punt $v$ in graaf $G$ heeft dus dezelfde omgeving als zijn afbeelding $f(v)$ in H. Hieruit volgt dat de graad van $v$ gelijk is aan de graad van $f(v)$. Er kan dus een initi\"ele partitie gemaakt worden op basis van graad. Voor de duidelijkheid zal er gesproken worden over verschillende kleuren in plaats van verschillende partities.

Omdat alle punten nu een bepaalde kleur hebben kan deze initi\"ele partitie verfijnd worden, namelijk op basis van de kleuromgeving van punt $v$. Deze kleuromgeving is als volgt gedefinieerd:

\begin{definition}
Neem $\alpha$, een partitie van graaf $G$ met $k$ verschillende kleuren en  $\alpha^{c}$ de verzameling punten van $G$ met kleur $c \in \{1,\ldots,k\}$. Twee punten $u,v \in V(G)$ hebben een \textbf{verschillende kleuromgeving} als er een kleur $c \in \{1,\ldots,k\}$ is zodanig dat $|N(u)\cap\alpha^{c}| \neq |N(v)\cap\alpha^{c}|$. Als dit niet geldt hebben de twee punten een \textbf{gelijke kleuromgeving}
\end{definition}
VERWIJZING!!!!

De partitie wordt nu dus verfijnd door elke groep op te splitsen in punten met een verschillende kleuromgeving, waarbij elke nieuwe groep uiteraard weer een nieuwe kleur krijgt. Omdat er weer punten met nieuwe kleuren zijn bijgekomen kan ook deze partitie weer verfijnd worden op basis van kleuromgeving. Dit proces wordt herhaald tot het niet meer mogelijk is een groep op te splitsen in nieuwe groepen met verschillende kleuromgevingen. Op dat moment bevinden zich in elke groep alleen maar elementen met dezelfde kleuromgeving, er wordt dan gesproken van een stabiele partitie.

Zoals eerder vermeld was behoud een isomorfisme de omgeving van een bepaald punt, een isomorfisme behoudt dus ook de kleuromgeving van een bepaald punt. In twee isomorfe graven bevindt zich dus een gelijke stabiele partitie. Met behulp van zo'n stabiele partitie kan er dan ofwel een isomorfisme gedefinieerd worden ofwel geconcludeerd worden dat er geen isomorfisme bestaat en dat de twee graven niet isomorf zijn.

\subsection{Hopcrofts algoritme}
Het nadeel van bovenstaand algoritme is dat, hoewel het een enorme verbetering is ten opzichte van een brute force methode nog steeds een complexiteit van $O(n^2)$ heeft, nog niet heel effici\"ent dus. Daarom is er gezocht naar een snellere implementatie van dit algoritme, zoals het algoritme van Hopcroft. Dat werkt als volgt.


Er wordt nog steeds begonnen met een initi\"ele partitie op basis van de graden van verschillende punten.
%------------------------------------------------

\subsection{Implementatie}
Onze implementatie 


\begin{algorithm}[H]
 \KwData{Een graaf $G(V,E)$ }
 \KwResult{Een stabiele partitie $a_{i}$ of G }
initalization \;
 \ForAll{ $v$ $\in$ $V(G)$ }{
	$\alpha(v) := v.degree()$
}
 $queue := [\alpha]$\;
 \While{$queue$ nonempty}{
  $c := dequeue(queue)$\;
  $d\_count := generate\_dcount(c)$\;
  \ForAll{$ color_{i} \in d\_count$}{
   \If{ $d\_count(color_{i}) > 1 $ }{
	$new\_color := x_{1} \in d\_counts(color_{i})$ \;
	\ForAll{ $ x_{i} \in d\_counts(color_{i}) | x_{i} \neq x_{1} $}{
	$c_{i} = x_{i} $ 
	}
   \eIf{$ new\_color \in queue $}{
	$ queue = \{c_{i}\} \cup queue $ \;
  } {
	neem grootste partitie
	$ F := max(\{ c_{i}, new\_color \} ) $ \;
	$ queue = \{ \{ new\_color \} / F \} \cup queue $

}	



  }
 }
}

 \caption{fast partition refinement}
\end{algorithm}
\pagebreak

\begin{algorithm}[H]
 \KwData{Een partitie $C$}
 \KwResult{Een Mapping $ \beta(c') \mapsto \gamma(neighbourcount) \mapsto \{ V_{i} \} $}
Een partitie mapt naar een mapping van een aantal buren, die weer mapt aan een lijst met vertices die dat aantal buren hebben. Zo kunnen wij gemakkelijk splitsen in nieuwe partities \;
 \ForAll{ $v$ $\in$ $C$ }{
\ForAll{ $v'$ $\in$ $N(v)$ }{
	$ neighbour\_count(v') =+ 1 $ \;
	$ colorset = colorset \cup  neighbour.colorclass  $  \;
}	
}


  \ForAll{$ color_{i} \in colorset $}{

	
	\ForAll{ $ v \in C $ }{
	\eIf{ $ v \in neighbour\_count $} {
	 	$ nbscount := neighbour\_count(v) $ \;
	} {
	$ nbscount := 0 $ \;
	$ d\_count(0) \cup v $ \;
	}
}
$ result(c) \cup d\_count $

	
  }
return result
 

\caption{$ generate\_dcount $}
\end{algorithm}




%------------------------------------------------
\subsection{Bewijs}

%------------------------------------------------
\section{Berekende resultaten}

The following conclusion follows directly from \eqref{eq:emc}.
\lipsum[6] % Dummy text
\begin{theorem}
Whenever two graphs $G$ and $G'$ are isomorphic, they share the same degree sequences.
\end{theorem}
\begin{proof}
Obvious.
\end{proof}
We immediately conclude the following.
\begin{corollary}
Whenever two planar graphs $G$ and $G'$ are isomorphic, their maximum degree vertices have the same degree. 
\end{corollary}
This observation first appeared in , and was later generalized to arbitrary graphs in .
In our implementation, we have therefore used the following algorithmic idea.
\begin{verbatim}
def gcd(a,b):
    if b > a:
        a,b = b,a
    r = a%b
    while r>0:
        a = b
        b = r
        r = a%b
    return b
\end{verbatim}
For more information on programming in {\tt python}, we refer to\cite{jaco} \cite{MR0403320}.

%------------------------------------------------
\section{Conclusie \& Discussie}
Het blijkt dus dat Hopcrofts algoritme een slimme manier is om een graaf te partitioneren. 

\lipsum[8] % Dummy text. 


%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------
 
% Bibliography - this is intentionally simple in this template
\bibliographystyle{plain}
\bibliography{referenties}

%----------------------------------------------------------------------------------------

\end{multicols}

\end{document}
